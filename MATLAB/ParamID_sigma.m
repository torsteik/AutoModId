% SCRIPT #4
n = input('\nDo you want to load:\n1 - Motor measurements\n2 - Rudder measurements\nAnswer: ');
if n == 1
    load('ActualMeasurementsMotor.mat');
elseif n == 2
    load('ActualMeasurementsRudder.mat');
else
    'Invalid input'
end

plot_bool = input('\nTurn on intermediate plots?\n1 - Yes\n2 - No\nAnswer: ');
%% Preprocess measurements
% Normalize state measurements
[x_ss_norm, x_ss_mean, x_ss_stdev] = zscore(x_ss');
[x_ts_norm, x_ts_mean, x_ts_stdev] = zscore(x_ts');

x_ss_norm = x_ss_norm';
x_ts_norm = x_ts_norm';

%% Regression setup
% A linear regression is used for the identification.
% The 'linear regression with L1 regularization'-solver solves:
%   minimize ||phi*beta-y||^2 + lambda*sum|beta_i|
%
% It is called as follows:
%   [beta,status,history] = l1_ls(phi,y,lambda [,tar_gap[,quiet]])

x = x_ss_norm;
y = sigma;

% Basis function:
% - The basis function, phi(x), in the regression of sigma(x) is a
%   4th order polynomial. 
phi = zeros(15,length(x));

for i = 1:size(phi,2)
    phi(:,i) = [ (n==1)*1         ... 
                 (n==1)*x(1,i)^1 (n==2)     *    x(2,i)^1  ...
                 (n==1)*x(1,i)^2 (n==2)*x(1,i)^1*x(2,i)^1  (n==1)     *    x(2,i)^2  ...
                 (n==1)*x(1,i)^3 (n==2)*x(1,i)^2*x(2,i)^1  (n==1)*x(1,i)^1*x(2,i)^2 (n==2)     *    x(2,i)^3  ...
                 (n==1)*x(1,i)^4 (n==2)*x(1,i)^3*x(2,i)^1  (n==1)*x(1,i)^2*x(2,i)^2 (n==2)*x(1,i)^1*x(2,i)^3  (n==1)*x(2,i)^4 ];
end

% Weighting scheme
weights = ones(1,length(x));
weights = diag(weights);

% Group measurements generated by equal inputs, tau, in cv
tau_seq_sigma = tau_seq(:,~invalid_ss);

K      = 15;                         % K-fold cv
inputs = unique(tau_seq_sigma','rows');
folds  = crossvalind('Kfold',length(inputs), K);
folds  = [inputs'; folds'];          % Roughly a dictionary with tau as 
                                     % key and cv folds as the value
buffer = zeros(1,length(sigma));
for i = 1:length(sigma)
    [~,j] = ismember(tau_seq_sigma(:,i)',folds(1:2,:)','rows');
    buffer(i) = folds(3,j);
end
folds = buffer;
cv_ind = folds;
figure(1)
hold on
grid on
for i = 1:K
    scatter3(x_ss(2,cv_ind == i), x_ss(1,cv_ind == i), sigma(cv_ind == i));
end


if n == 2
    %% Hyperparameter #1: rudder bias, b
    % Weighting scheme for finding rudder bias:
    %   - Heavily prioritize points nearest ROT = 0 and with medium to high SOG
    weights_b = ones(1,length(x));

    tau_seq_sigma = tau_seq(:,~invalid_ss);
    ind = find(tau_seq_sigma(2,:) == 0.1);
    weights_b(ind(3:end)) = 50;
    ind = find(tau_seq_sigma(2,:) == 0.4);
    weights_b(ind(1:end)) = 1;
    
    weights_b = diag(weights_b);
    
    % Cross validation
    b_max     = 0;
    b_min     =-7;
    delta_max = 40;
    b_res     = 100;

    biases = linspace(b_min,b_max,b_res);
    biases = biases./delta_max;

    lambda_b = 0.001;
    err_b = zeros(1,length(biases));
    y_b   = zeros(1,length(y));
    for i = 1:length(biases)
        % Add and subtract bias from measurements according to symmetri assumption
        y_b(1:(end/2))     = y(1:(end/2))     + biases(i);
        y_b((end/2+1):end) = y((end/2+1):end) - biases(i);
        for fold = 1:K
            % Determine which measurements to use in validation in this iteration
            y_valid = y_b(folds == fold);
            y_train = y_b(folds ~= fold);

            phi_valid = phi(:, folds == fold);
            phi_train = phi(:, folds ~= fold);

            weights_train = weights_b(folds ~= fold, folds ~= fold);

            % Solve for the parameter vector, beta, using training set and current lambda
            beta = l1_ls(sqrt(weights_train)*phi_train',sqrt(weights_train)*y_train',lambda_b,[],true);

            % Evaluate validation set with the obtained beta and store validation error
            err_b(i) = err_b(i) + sum( (beta'*phi_valid - y_valid).^2 )/length(y_valid);
        end
    end

    % Choose the b value that gave the lowest validation error
    % and include it to the measurements
    [~,ind] = min(err_b);
    b = biases(ind);

    y(1:(end/2))     = y(1:(end/2))     + b;
    y((end/2+1):end) = y((end/2+1):end) - b;
    
    if plot_bool == 1
        %% Plot
        set(groot, 'defaulttextinterpreter','latex'); 
        set(groot, 'defaultAxesTickLabelInterpreter','latex');
        set(groot, 'defaultLegendInterpreter','latex');

        err_b_fig = figure(400+n);
        clf(err_b_fig,'reset')

        err_b_ax = axes;
        hold(err_b_ax,'on');
        err_b_ax.XGrid = 'on';
        err_b_ax.YGrid = 'on';
        err_b_ax.ZGrid = 'on';
        err_b_ax.LineWidth = 1;

        err_b_plot = plot(err_b_ax, biases, err_b);
        err_b_plot.LineWidth   = 1;

        xlabel(err_b_ax,'$b$');
        ylabel(err_b_ax,'Error');
        
        r2d = 180/pi;
        % Visualize correctional shift caused by rudder bias
        b_id_fig = figure(402+n);
        clf(b_id_fig,'reset')

        b_id_ax = axes;
        b_id_ax.PlotBoxAspectRatio = [1 1 1];
        hold(b_id_ax,'on');
        b_id_ax.XGrid = 'on';
        b_id_ax.YGrid = 'on';
        b_id_ax.ZGrid = 'on';
        b_id_ax.LineWidth = 1;

        b_id_scat = scatter3(b_id_ax,x_ss(2,:).*r2d,x_ss(1,:),y);
        b_id_scat.Marker = 'o';
        b_id_scat.MarkerEdgeColor = 'r';
        b_id_scat.MarkerFaceColor = 'r';
        b_id_scat.SizeData = 7;
        
        no_b_scat = scatter3(b_id_ax,x_ss(2,:).*r2d,x_ss(1,:),sigma);
        no_b_scat.Marker = 'o';
        no_b_scat.MarkerEdgeColor = 'b';
        no_b_scat.MarkerFaceColor = 'b';
        no_b_scat.SizeData = 7;

        xlabel(b_id_ax,'ROT [deg/s]');
        ylabel(b_id_ax,'SOG [m/s]');
        zlabel(b_id_ax,'$\sigma_r$');

        b_leg = legend(b_id_ax, 'Corrected','Uncorrected');       
    end
end

%% Hyperparameter #2: regularization coefficient, lambda
% Perform CV
lambda_res = 100;                    % 'Resolution' of the cv
lambdas = linspace(0.01,2,lambda_res);

err_lambda = zeros(1,length(lambdas));
for i = 1:length(lambdas)
    for fold = 1:K
        % Use measurments belonging to fold for validation, train on rest
        y_valid = y(folds == fold);
        y_train = y(folds ~= fold);

        phi_valid = phi(:, folds == fold);
        phi_train = phi(:, folds ~= fold);
        
        weights_train = weights(folds ~= fold, folds ~= fold);
        
        % Solve for the parameter vector, beta, using training set and current lambda
        beta = l1_ls(sqrt(weights_train)*phi_train', sqrt(weights_train)*y_train', lambdas(i), [],true);
        
        % Evaluate validation set with the obtained beta and store validation error
        err_lambda(i) = err_lambda(i) + sum( (beta'*phi_valid - y_valid).^2 )/length(y_valid);
    end
end

% Choose the lambda value that gave the lowest validation error
[~,ind] = min(err_lambda);
lambda  = lambdas(ind);

if plot_bool == 1
    %% Plot
    err_lam_fig = figure(404+n);
    clf(err_lam_fig,'reset')

    err_lam_ax = axes;
    hold(err_lam_ax,'on');
    err_lam_ax.XGrid = 'on';
    err_lam_ax.YGrid = 'on';
    err_lam_ax.ZGrid = 'on';
    err_lam_ax.LineWidth = 1;

    err_lam_plot = plot(err_lam_ax, lambdas, err_lambda);
    err_lam_plot.LineWidth   = 1;
    
    xlabel(err_lam_ax,'$\lambda$');
    ylabel(err_lam_ax,'Error');
end

%% Complete the identification using the chosen lambda
beta = l1_ls(sqrt(weights)*phi',sqrt(weights)*y',lambda,[],true);

% Store results
model_sig = struct;
model_sig.phi  = phi;
model_sig.beta = beta;
model_sig.x_mean  = x_ss_mean;
model_sig.x_stdev = x_ss_stdev;


%% Plot
r2d = 180/pi;
% Set up for surface plot
xy_surf = [linspace(min(x(1,:)),max(x(1,:)),30);
           linspace(min(x(2,:)),max(x(2,:)),30)];
z_surf  = zeros(length(xy_surf(1,:)),length(xy_surf(2,:)));
      
[X,Y] = meshgrid(xy_surf(1,:),xy_surf(2,:));
phi   = zeros(15,length(xy_surf(1,:)),length(xy_surf(2,:)));

for i = 1:length(xy_surf(1,:))
    for j = 1:length(xy_surf(1,:))
        phi(:,i,j) = [ (n==1)*1         ... 
                       (n==1)*X(i,j)^1 (n==2)     *    Y(i,j)^1  ...
                       (n==1)*X(i,j)^2 (n==2)*X(i,j)^1*Y(i,j)^1 (n==1)     *    Y(i,j)^2  ...
                       (n==1)*X(i,j)^3 (n==2)*X(i,j)^2*Y(i,j)^1 (n==1)*X(i,j)^1*Y(i,j)^2 (n==2)     *    Y(i,j)^3  ...
                       (n==1)*X(i,j)^4 (n==2)*X(i,j)^3*Y(i,j)^1 (n==1)*X(i,j)^2*Y(i,j)^2 (n==2)*X(i,j)^1*Y(i,j)^3  (n==1)*Y(i,j)^4 ];
    end
end

for i = 1:length(xy_surf(1,:))
    for j = 1:length(xy_surf(2,:))
        z_surf(i,j) = phi(:,i,j)'*model_sig.beta;
    end
end

X_unorm = model_sig.x_mean(1) + model_sig.x_stdev(1).*X;
Y_unorm =(model_sig.x_mean(2) + model_sig.x_stdev(2).*Y).*r2d;

% Plot modelsurface against measurements
set(groot, 'defaulttextinterpreter','latex'); 
set(groot, 'defaultAxesTickLabelInterpreter','latex');
set(groot, 'defaultLegendInterpreter','latex');

sig_id_fig = figure(406+n);
clf(sig_id_fig,'reset')

sig_id_ax = axes;
sig_id_ax.PlotBoxAspectRatio = [1 1 1];
hold(sig_id_ax,'on');
sig_id_ax.XGrid = 'on';
sig_id_ax.YGrid = 'on';
sig_id_ax.ZGrid = 'on';
sig_id_ax.LineWidth = 1;

sig_id_scat = scatter3(sig_id_ax,x_ss(2,:).*r2d,x_ss(1,:),y);
sig_id_scat.Marker = 'o';
sig_id_scat.MarkerEdgeColor = 'r';
sig_id_scat.MarkerFaceColor = 'r';
sig_id_scat.SizeData = 7;

sig_id_surf = surf(sig_id_ax, Y_unorm, X_unorm, z_surf);
sig_id_surf.EdgeColor = 'interp';
sig_id_surf.FaceColor = [0.6 0.6 0.6];
sig_id_surf.LineWidth = 1;

xlabel(sig_id_ax,'ROT [deg/s]');
ylabel(sig_id_ax,'SOG [m/s]');
zlabel(sig_id_ax,strcat('$\sigma',(n==1)*'_U$',(n==2)*'_r$'));

sig_leg = legend(sig_id_ax, '$\mathbf{D}_{\sigma}$');

%sig_id_ax.XLim = [min(x_ss(2,:)) max(x_ss(2,:))].*r2d;
%sig_id_ax.YLim = [0 max(x_ss(1,:))];
sig_id_ax.ZLim = [min(y) max(y)];
